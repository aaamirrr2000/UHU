@page "/InvoicePage/{InvoiceType}/{Action}/{CurrentRecord:int?}"

@using System.Text.Json
@using NG.MicroERP.Shared.Pages.TaxRule
@using NG.MicroERP.Shared.Models
@using NG.MicroERP.Shared.Pages.Invoices
@inject NavigationManager NavManager
@inject IDialogService dialogService
@inject ISnackbar Snackbar
@inject IJSRuntime JS
@inject Globals Globals
@inject Functions Functions
@inject ISnackbar SnackbarService

<PageTitle>@InvoiceType INVOICE</PageTitle>
<Loading IsLoading="@LoadingPanel" />

<MyModelDialog Width="70%" Height="70%" @ref="_myTaxDialog" Title="Tax Calculation">
    <HeaderContent></HeaderContent>
    <ChildContent>
        @if (SelectedItem != null && SelectedItem.Id > 0 && record?.Invoice?.PartyId > 0)
        {
            <ItemTaxPreview ItemId="SelectedItem.Id" PartyId="record.Invoice.PartyId" Quantity="SelectedItem.Qty" />
        }
        else
        {
            <MudText Typo="Typo.body1" Class="text-center pa-4">Please select an item to view tax details.</MudText>
        }
    </ChildContent>
    <FooterContent></FooterContent>
</MyModelDialog>

<MudLayout>
    <!-- Modern Gradient Header -->
    <MudContainer MaxWidth="MaxWidth.False" Class="pa-2">
        <div class="invoice-header-gradient mb-3">
            <div class="d-flex align-items-center justify-content-between flex-wrap gap-2">
                <div class="d-flex align-items-center gap-2 flex-shrink-0">
                    <MudIcon Icon="@Icons.Material.Filled.Receipt" 
                             Size="Size.Medium" 
                             Style="color: white; font-size: 2rem;" />
                    <div>
                        <MudText Typo="Typo.h5" Class="mb-0 fw-bold" Style="color: white;">
                            @InvoiceType Invoice
                        </MudText>
                        <MudText Typo="Typo.body2" Class="mt-0" Style="color: rgba(255,255,255,0.85) !important; font-size: 0.75rem;">
                            @(CurrentRecord.GetValueOrDefault() > 0 ? $"Invoice #{record.Invoice.Code}" : "Create new invoice")
                        </MudText>
                    </div>
                </div>
                <div class="d-flex align-items-center gap-1 flex-wrap" style="flex: 1; justify-content: flex-end; min-width: 0;">
                    <MudButton StartIcon="@Icons.Material.TwoTone.Menu"
                               Variant="Variant.Filled"
                               Color="Color.Info"
                               Size="Size.Small"
                               OnClick="OpenOptionsDrawer"
                               Class="invoice-header-btn">
                        More
                    </MudButton>

                    <MudButton StartIcon="@Icons.Material.TwoTone.Add"
                               Variant="Variant.Filled"
                               Color="Color.Warning"
                               Size="Size.Small"
                               OnClick="Clear"
                               Class="invoice-header-btn">
                        New
                    </MudButton>

                    @if (!string.Equals(Action, "VIEW", StringComparison.OrdinalIgnoreCase) && !Disabled)
                    {
                        <MudButton StartIcon="@(CurrentRecord.GetValueOrDefault() != 0 ? Icons.Material.TwoTone.Edit : Icons.Material.TwoTone.Save)"
                                   Variant="Variant.Filled"
                                   Color="Color.Success"
                                   Size="Size.Small"
                                   OnClick="Save"
                                   Class="invoice-header-btn">
                            @(CurrentRecord.GetValueOrDefault() != 0 ? "Update" : "Save")
                        </MudButton>
                    }

                    <MudButton StartIcon="@Icons.Material.TwoTone.Print"
                               Variant="Variant.Filled"
                               Color="Color.Secondary"
                               Size="Size.Small"
                               OnClick="Print"
                               Disabled="@(CurrentRecord.GetValueOrDefault() == 0 && !_isInvoiceSaved)"
                               Class="invoice-header-btn">
                        Print
                    </MudButton>

                    <!-- Preview GL Entry - Available before and after saving -->
                    <MudButton StartIcon="@Icons.Material.TwoTone.Preview"
                               Variant="Variant.Outlined"
                               Color="Color.Info"
                               Size="Size.Small"
                               OnClick="ShowGLPreview"
                               Class="invoice-header-btn"
                               Disabled="@(record?.Invoice?.PartyId == 0 || record?.InvoiceDetails == null || !record.InvoiceDetails.Any())">
                        @(CurrentRecord.GetValueOrDefault() > 0 && record?.Invoice?.IsPostedToGL == 1 ? "View GL Entry" : "Preview GL Entry")
                    </MudButton>

                </div>
            </div>
        </div>

        <!-- Period Validation Warning - Only show when CLOSED -->
        @if (PeriodValidationChecked && !string.IsNullOrWhiteSpace(PeriodValidationMessage) && PeriodValidationMessage.Contains("CLOSED"))
        {
            <MudAlert Severity="Severity.Warning" Class="mb-2" Variant="Variant.Outlined" Dense="true">
                <MudText Typo="Typo.body2">@PeriodValidationMessage</MudText>
            </MudAlert>
        }

        <!-- Invoice Details Card -->
        <MudPaper Elevation="2" Class="pa-2 mb-2 invoice-details-paper" Style="border-radius: 12px; background: linear-gradient(135deg, rgba(63, 81, 181, 0.05) 0%, rgba(63, 81, 181, 0.02) 100%); border: 1px solid rgba(63, 81, 181, 0.12);">
            <div class="invoice-details-row">
                <div class="invoice-field invoice-field-equal">
                    <MudSelect T="string"
                               Label="Invoice Type"
                               @bind-Value="record.Invoice.InvoiceType"
                               Variant="Variant.Outlined"
                               Dense="@true"
                               Disabled="@(Disabled || IsInvoiceTypeAndDateLocked)"
                               FullWidth="@true"
                               Margin="Margin.Dense"
                               Class="invoice-field-input">
                        @foreach (var option in InvoiceTypeList ?? Enumerable.Empty<string>())
                        {
                            <MudSelectItem T="string" Value="@option">@option</MudSelectItem>
                        }
                    </MudSelect>
                </div>

                <div class="invoice-field invoice-field-equal">
                    <div class="d-flex align-items-center gap-1">
                        <MudAutocomplete T="PartiesModel"
                                         Label="Party / Customer"
                                         Value="SelectedParty"
                                         ValueChanged="OnPartyChanged"
                                         ToStringFunc="@(p => p?.DisplayName)"
                                         SearchFunc="@SearchParties"
                                         Clearable="@true"
                                         Variant="Variant.Outlined"
                                         Dense="@true"
                                         Disabled="@(record?.InvoiceDetails?.Count > 0)"
                                         FullWidth="@true"
                                         Margin="Margin.Dense"
                                         Class="invoice-field-input flex-grow-1" />
                        @if (!Disabled && record?.InvoiceDetails?.Count == 0)
                        {
                            <MudTooltip Text="Add New Party">
                                <MudIconButton Icon="@Icons.Material.Filled.Add"
                                               Size="Size.Small"
                                               Variant="Variant.Text"
                                               Color="Color.Primary"
                                               OnClick="OpenNewPartyDialog"
                                               Style="margin-top: 8px;" />
                            </MudTooltip>
                        }
                    </div>
                </div>

                <div class="invoice-field invoice-field-equal">
                    <MudDatePicker Label="Transaction Date"
                                   @bind-Date="record.Invoice.TranDate"
                                   @bind-Date:after="OnTranDateChanged"
                                   Variant="Variant.Outlined"
                                   Dense="@true"
                                   Placeholder="Select Date"
                                   DateFormat="yyyy-MM-dd"
                                   Disabled="@(Disabled || IsInvoiceTypeAndDateLocked)"
                                   FullWidth="@true"
                                   Margin="Margin.Dense"
                                   Class="invoice-field-input" />
                </div>

                <div class="invoice-field invoice-field-equal">
                    <MudTextField Label="Invoice Number"
                                  Value="@record.Invoice.Code"
                                  ReadOnly="@true"
                                  Variant="Variant.Outlined"
                                  Dense="@true"
                                  FullWidth="@true"
                                  Margin="Margin.Dense"
                                  Class="invoice-field-input" />
                </div>

                <!-- Currency Display (read-only, edit in drawer) -->
                <div class="invoice-field invoice-field-equal">
                    <MudTextField Value="@(Currencies.FirstOrDefault(c => c.Id == record.Invoice.EnteredCurrencyId)?.DisplayName ?? Currencies.FirstOrDefault(c => c.Id == record.Invoice.BaseCurrencyId)?.DisplayName ?? "N/A")"
                                  ReadOnly="@true"
                                  Variant="Variant.Outlined"
                                  Dense="@true"
                                  FullWidth="@true"
                                  Margin="Margin.Dense"
                                  HelperText="@(record.Invoice.EnteredCurrencyId != record.Invoice.BaseCurrencyId ? $"Rate: {record.Invoice.ExchangeRate:N6}" : null)"
                                  Class="invoice-field-input" />
                </div>
            </div>

            <!-- Description Field -->
            <div class="invoice-field" style="width: 100%; margin-top: 8px;">
                <MudTextField Label="Description"
                              @bind-Value="record.Invoice.Description"
                              Placeholder="Enter invoice description or notes"
                              Variant="Variant.Outlined"
                              Dense="@true"
                              Disabled="@Disabled"
                              FullWidth="@true"
                              Margin="Margin.Dense"
                              MaxLength="255"
                              Class="invoice-field-input" />
            </div>
        </MudPaper>
    </MudContainer>


    <!-- Items Drawer (Right Side) -->
    <MyDrawer @ref="_itemsDrawer"
              Title="Items Catalog"
              FaIcon="fas fa-box-open"
              @bind-Open="_itemsDrawerOpen">
        <HeaderContent>
            <!-- Barcode Search -->
            <MudPaper Elevation="1" Class="pa-3 mb-3" Style="border-radius: 12px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%); border: 1px solid rgba(255, 255, 255, 0.2);">
                <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
                    <MudTextField T="string"
                                  Dense="@true"
                                  Variant="Variant.Outlined"
                                  Placeholder="Scan or Enter Barcode"
                                  @bind-Value="ClickedItem.Code"
                                  Style="flex: 1; min-width: 0; background: white;"
                                  Adornment="Adornment.Start"
                                  AdornmentIcon="@Icons.Material.Filled.QrCodeScanner"
                                  @onkeypress="@(async (e) => { if (e.Key == "Enter" || e.Key == "\r") await AddItemDialogShowWithType(ClickedItem.Code, "s"); })" />
                    <MudTooltip Text="Search by barcode">
                        <MudIconButton Icon="@Icons.Material.Filled.Search"
                                       Size="Size.Medium"
                                       Variant="Variant.Filled"
                                       Color="Color.Primary"
                                       OnClick='async () => await AddItemDialogShowWithType(ClickedItem.Code, "s")' />
                    </MudTooltip>
                </div>
            </MudPaper>
        </HeaderContent>
        <ChildContent>
            <InvoiceItemsTabs Categories="_categories"
                              SelectedItems="SelectedItems"
                              FavItemsData="FavItemsData"
                              RecentItemsData="RecentItemsData"
                              MaxItems="MaxItems"
                              ClickedItem="ClickedItem"
                              SelectedFavItem="SelectedFavItem"
                              SelectedRecentItem="SelectedRecentItem"
                              OnCategorySelected="LoadItemsByCategory"
                              OnItemSelected="HandleItemSelected"
                              ActiveCategory="_activeCategory"
                              InvoiceType="InvoiceType"
                              GetDisplayPrice="GetDisplayPrice"
                              HasTaxRule="HasTaxRule" />
        </ChildContent>
        <FooterContent>
        </FooterContent>
    </MyDrawer>

    <MudMainContent Class="p-3 invoice-main-content" Style="margin-left:0; margin-right: 16px; overflow-x: hidden; overflow-y: auto; max-height: calc(100vh - 280px);">
        <MudGrid Spacing="2" GutterSize="GutterSize.Small">
            <MudItem xs="12">
                <InvoiceItemsTable Record="record"
                                   Disabled="Disabled"
                                   Action="Action"
                                   InvoiceType="InvoiceType"
                                   OriginalItemIds="_originalItemIds"
                                   OnDeleteItem="DeleteItem"
                                   OnItemSelection="OnItemSelection"
                                   OnRowQtyChanged="OnRowQtyChangedAsync"
                                   TotalQty="TotalQty"
                                   TotalDiscountAmount="TotalDiscountAmount"
                                   TotalTaxAmount="TotalTaxAmount"
                                   OnTaxClick="OpenTaxDialog"
                                   OnPaymentClick="OpenPaymentDialog"
                                   OnClose="ClosePaymentDialog"
                                   OnAmountChanged="OnChargesDiscountChangedAsync"
                                   ChargesManuallyOverridden="_chargesManuallyOverridden"
                                   DiscountManuallyOverridden="_discountManuallyOverridden"
                                   OnResetChargesClick="ResetChargesToAuto"
                                   OnResetDiscountClick="ResetDiscountToAuto"
                                   OnAddManualLineClick="AddManualLine"
                                   OnBrowseItemsClick="OpenItemsDrawer" />
            </MudItem>
        </MudGrid>
    </MudMainContent>

    <InvoiceOptionsDrawer @ref="_optionsDrawer"
                          Record="record"
                          Parties="Parties"
                          SalesId="SalesId"
                          InvoiceStatus="InvoiceStatus"
                          Accounts="Accounts"
                          Currencies="Currencies"
                          Disabled="Disabled"
                          IsInvoiceTypeAndDateLocked="IsInvoiceTypeAndDateLocked" />

    <InvoicePaymentDialog @ref="_paymentDialog"
                          Record="record"
                          InvoicePayments="InvoicePayments"
                          PaymentMethod="PaymentMethod"
                          OnPaymentMethodChange="OnPaymentMethodChange"
                          OnAddPayment="AddPayment"
                          OnDeletePayment="DeletePayment"
                          OnClose="ClosePaymentDialog"
                          Disabled="Disabled" />

    <InvoiceTaxDialog @ref="_tax_dialog"
                      Record="record" />

    <InvoiceItemDetailsDialog @ref="_itemDetailsDialog"
                              SelectedItem="SelectedItem"
                              InvoiceType="InvoiceType"
                              OnAddToCart="AddToCart"
                              OnQtyChanged="OnQtyChangedAsync"
                              OnServingSizeChanged="OnServingSizeChangedAsync" />
</MudLayout>

@code {
    [Parameter] public int? CurrentRecord { get; set; } = 0;
    [Parameter] public string? Action { get; set; } = "INSERT";
    [Parameter] public string InvoiceType { get; set; }
    [Parameter] public EventCallback OnSaved { get; set; }

    public List<string> InvoiceTypeList { get; set; } = new();
    [CascadingParameter] private bool isReadOnly { get; set; }
    public bool Disabled { get; set; } = true;
    private bool LoadingPanel { get; set; } = false;

    // Main Models
    private InvoicesModel record = new();
    private InvoicePaymentModel InvoicePayments = new();

    // Components
    private InvoiceOptionsDrawer _optionsDrawer = new();
    private InvoicePaymentDialog _paymentDialog = new();
    private InvoiceTaxDialog _tax_dialog = new();
    private InvoiceItemDetailsDialog _itemDetailsDialog = new();
    private MyDrawer _itemsDrawer = new();
    private bool _itemsDrawerOpen = false;

    // Supporting Lists
    private List<PartiesModel> Parties = new();
    private PartiesModel SelectedParty = new();
    public List<EmployeesModel> SalesId { get; set; } = new();
    private List<CategoriesModel> _categories = new();
    private CategoriesModel _activeCategory;
    private List<ChartOfAccountsModel> PaymentMethod = new();
    private List<ChartOfAccountsModel> Accounts = new();
    private List<TypeCodeModel> InvoiceStatus = new();
    private List<CurrenciesModel> Currencies = new();

    // Items Data
    private List<ItemsModel> ItemsData { get; set; } = new();
    private List<ItemsModel> FavItemsData = new();
    private List<ItemsModel> RecentItemsData = new();
    public int MaxItems { get; set; } = 12;
    public List<ItemsModel> SelectedItems { get; set; } = new();
    public ItemsModel SelectedItem { get; set; } = new();
    public ItemsModel ClickedItem { get; set; } = new();
    public ItemsModel SelectedFavItem { get; set; } = new();
    public ItemsModel SelectedRecentItem { get; set; } = new();

    // Computed Properties
    private double TotalQty => record?.InvoiceDetails?.Sum(i => i.Qty) ?? 0;
    private double TotalDiscountAmount => record?.InvoiceDetails?.Sum(i => i.DiscountAmount) ?? 0;
    private double TotalTaxAmount => record?.InvoiceDetails?.Sum(i => i.TaxAmount) ?? 0;

    public MyModelDialog? _myTaxDialog;
    private Dictionary<(int ItemId, int PartyId), List<ItemPartyTaxCalculationModel>> _taxCache = new();
    private HashSet<int> _itemsWithTaxRules = new();
    private bool _isInvoiceSaved = false;
    private bool _hasChanges = false;
    private InvoicesModel _originalRecord = new();
    private HashSet<int> _originalItemIds = new();
    private bool IsInvoiceTypeAndDateLocked => Disabled || (record?.Invoice?.IsPostedToGL == 1);
    private List<ItemPartyTaxCalculationModel> SelectedItemTaxes { get; set; } = new();
    private double SelectedItemTaxTotal { get; set; } = 0;
    private static int _tempDetailIdCounter = -1;
    private string PeriodValidationMessage { get; set; } = string.Empty;
    private bool PeriodValidationChecked { get; set; } = false;
    
    // Track if charges and discounts were manually overridden
    private bool _chargesManuallyOverridden = false;
    private bool _discountManuallyOverridden = false;

    // ========== Initialization Methods ==========
    protected override async Task OnInitializedAsync()
    {
        InitializeInvoice();
        await GetAll();
    }

    protected override async Task OnParametersSetAsync()
    {
        InitializeInvoice();
        
        // Ensure data is loaded before trying to get invoice
        if (ItemsData == null || !ItemsData.Any())
        {
            await LoadAllItemsData();
        }
        
        if (!string.Equals(Action, "INSERT", StringComparison.OrdinalIgnoreCase) && CurrentRecord.HasValue && CurrentRecord.Value != 0)
        {
            await Get(CurrentRecord);
        }
        else if (SelectedParty == null && record?.Invoice?.PartyId > 0)
        {
            SelectedParty = Parties.FirstOrDefault(p => p.Id == record.Invoice.PartyId);
        }
        
        // Validate period if we have a date set
        if (record?.Invoice?.TranDate != null && record.Invoice.OrganizationId > 0)
        {
            await ValidatePeriodAsync();
        }
        
        StateHasChanged();
    }

    private void InitializeInvoice()
    {
        EnsureInvoiceInitialized();
        Disabled = string.Equals(Action, "VIEW", StringComparison.OrdinalIgnoreCase);
        
        // Disable if posted to GL
        if (record?.Invoice?.IsPostedToGL == 1)
        {
            Disabled = true;
        }

        if (string.Equals(Action, "INSERT", StringComparison.OrdinalIgnoreCase) && CurrentRecord.GetValueOrDefault() == 0)
        {
            Disabled = false;
            record.Invoice.InvoiceType = InvoiceType;
            record.Invoice.TranDate = DateTime.Now;
            record.Invoice.OrganizationId = Globals.User.OrganizationId; // Set OrganizationId for validation
        }
    }

    // ========== Data Loading Methods ==========
    private async Task GetAll()
    {
        EnsureInvoiceInitialized();
        LoadingPanel = true;

        try
        {
            Currencies = await Functions.GetAsync<List<CurrenciesModel>>($"Currencies/Search", true) ?? new List<CurrenciesModel>();
            await LoadCategories();
            await LoadAllItemsData();
            await LoadReferenceData();
            await LoadParties();
            await SetDefaultValues();

            // Validate period after setting default values (includes default TranDate)
            await ValidatePeriodAsync();

            if (_categories.Any())
            {
                _activeCategory = _categories[0];
                await LoadItemsByCategory(_categories[0]);
            }
        }
        catch (Exception ex)
        {
            ShowError($"Error loading data: {ex.Message}");
        }
        finally
        {
            LoadingPanel = false;
        }
    }

    private async Task LoadAllItemsData()
    {
        ItemsData = await Functions.GetAsync<List<ItemsModel>>("Items/Search", true) ?? new List<ItemsModel>();
        
        // Initialize retail prices (will be recalculated when party is selected)
        InitializeItemRetailPrices(ItemsData);
        
        // Filter favorites and recent items
        FavItemsData = ItemsData
            .Where(i => i.IsFavorite == 1)
            .OrderByDescending(i => i.IsFavorite)
            .ThenByDescending(i => i.Id)
            .Take(MaxItems)
            .ToList();
        
        RecentItemsData = ItemsData
            .OrderByDescending(i => i.Recent_Sales_Volume)
            .ThenByDescending(i => i.IsFavorite)
            .ThenByDescending(i => i.Id)
            .Take(MaxItems)
            .ToList();
        
        // Recalculate prices if party is selected (non-blocking)
        int partyId = SelectedParty?.Id ?? record?.Invoice?.PartyId ?? 0;
        if (partyId > 0 && !string.Equals(InvoiceType, "purchase", StringComparison.OrdinalIgnoreCase))
        {
            _ = CalculateRetailPricesForItemsAsync();
        }
    }
    
    private void InitializeItemRetailPrices(List<ItemsModel> items)
    {
        bool isPurchase = string.Equals(InvoiceType, "purchase", StringComparison.OrdinalIgnoreCase);
        foreach (var item in items)
        {
            item.RetailPrice = isPurchase ? item.CostPrice : item.BasePrice - item.DefaultDiscount;
        }
    }
    
    private async Task CalculateRetailPricesForItemsAsync()
    {
        try
        {
            int partyId = SelectedParty?.Id ?? record?.Invoice?.PartyId ?? 0;
            if (partyId == 0 || ItemsData == null || !ItemsData.Any()) return;
            
            if (string.Equals(InvoiceType, "purchase", StringComparison.OrdinalIgnoreCase))
            {
                InitializeItemRetailPrices(ItemsData);
                return;
            }
            
            await RecalculateItemPricesInList(ItemsData, partyId);
            await InvokeAsync(StateHasChanged);
        }
        catch { /* ignore errors in background calculation */ }
    }

    private async Task LoadReferenceData()
    {
        string PaymentMethods = "InterfaceType = 'PAYMENT METHOD'";
        PaymentMethod = await Functions.GetAsync<List<ChartOfAccountsModel>>($"ChartOfAccounts/Search/{PaymentMethods}", true) ?? new List<ChartOfAccountsModel>();
        Accounts = await Functions.GetAsync<List<ChartOfAccountsModel>>("ChartOfAccounts/Search", true) ?? new List<ChartOfAccountsModel>();
        InvoiceStatus = await Functions.GetAsync<List<TypeCodeModel>>("TypeCode/Search/INVOICE STATUS", true) ?? new List<TypeCodeModel>();
        SalesId = await Functions.GetAsync<List<EmployeesModel>>("Employees/Search", true) ?? new List<EmployeesModel>();
    }

    private async Task LoadParties()
    {
        string partyType = InvoiceType != null && InvoiceType.StartsWith("SALE", StringComparison.OrdinalIgnoreCase)
            ? "CUSTOMER"
            : "SUPPLIER";

        Parties = await Functions.GetAsync<List<PartiesModel>>($"Parties/Search/a.PartyType='{partyType}'", true) ?? new List<PartiesModel>();
    }

    private async Task SetDefaultValues()
    {
        InitializeInvoiceTypeList();

        if (Parties != null && Parties.Any())
        {
            record.Invoice.PartyId = Parties.First().Id;
            await OnPartyChanged(Parties.First());
        }

        if (InvoiceStatus != null && InvoiceStatus.Any())
            record.Invoice.Status = InvoiceStatus.First().ListValue;

        if (SalesId != null && SalesId.Any())
            record.Invoice.SalesId = SalesId.First().Id;
    }

    private void InitializeInvoiceTypeList()
    {
        InvoiceTypeList.Clear();
        if (string.Equals(InvoiceType, "SALE", StringComparison.OrdinalIgnoreCase))
        {
            InvoiceTypeList.Add("SALE");
            InvoiceTypeList.Add("SALE RETURN");
        }
        else
        {
            InvoiceTypeList.Add("PURCHASE");
            InvoiceTypeList.Add("PURCHASE RETURN");
        }
    }

    private async Task Get(int? id)
    {
        if (id.HasValue && id.Value != 0)
        {
            EnsureInvoiceInitialized();
            LoadingPanel = true;

            try
            {
                record = await Functions.GetAsync<InvoicesModel>($"Invoice/Get?Id={id.Value}", true) ?? new InvoicesModel();
                
                // Ensure all collections are initialized
                EnsureInvoiceInitialized();
                
                // Load payments if not loaded
                if (record.InvoicePayments == null || record.InvoicePayments.Count == 0)
                {
                    record.InvoicePayments = new ObservableCollection<InvoicePaymentModel>();
                }
                
                // Load charges if not loaded
                if (record.InvoiceCharges == null || record.InvoiceCharges.Count == 0)
                {
                    record.InvoiceCharges = new ObservableCollection<InvoiceChargesModel>();
                }
                
                // Load taxes if not loaded
                if (record.InvoiceTaxes == null || record.InvoiceTaxes.Count == 0)
                {
                    record.InvoiceTaxes = new ObservableCollection<InvoiceDetailTaxesModel>();
                }
                
                // Ensure ItemsData is loaded before processing
                if (ItemsData == null || !ItemsData.Any())
                {
                    await LoadAllItemsData();
                }
                
                // Ensure ItemsData includes all items from invoice details (for item name display)
                if (record.InvoiceDetails != null && record.InvoiceDetails.Count > 0)
                {
                    var missingItemIds = record.InvoiceDetails
                        .Where(d => d.ItemId > 0 && (ItemsData == null || !ItemsData.Any(i => i.Id == d.ItemId)))
                        .Select(d => d.ItemId)
                        .Distinct()
                        .ToList();
                    
                    if (missingItemIds.Any())
                    {
                        // Load missing items (use individual calls but in parallel for better performance)
                        var loadTasks = missingItemIds.Select(async itemId =>
                        {
                            try
                            {
                                var item = await Functions.GetAsync<ItemsModel>($"Items/Get/{itemId}", true);
                                if (item != null && (ItemsData == null || !ItemsData.Any(i => i.Id == item.Id)))
                                {
                                    if (ItemsData == null) ItemsData = new List<ItemsModel>();
                                    ItemsData.Add(item);
                                }
                            }
                            catch { /* ignore individual item load errors */ }
                        });
                        
                        await Task.WhenAll(loadTasks);
                    }
                    
                    // Populate ItemName from ItemsData if it's missing in invoice details
                    if (ItemsData != null && ItemsData.Any())
                    {
                        foreach (var detail in record.InvoiceDetails)
                        {
                            if (string.IsNullOrWhiteSpace(detail.ItemName) && detail.ItemId > 0)
                            {
                                var item = ItemsData.FirstOrDefault(i => i.Id == detail.ItemId);
                                if (item != null && !string.IsNullOrWhiteSpace(item.Name))
                                {
                                    detail.ItemName = item.Name;
                                }
                            }
                        }
                    }
                }
                
                // Set selected party
                if (record.Invoice.PartyId > 0)
                {
                    SelectedParty = Parties.FirstOrDefault(p => p.Id == record.Invoice.PartyId) ?? new PartiesModel();
                    // Set AccountId from party if available
                    if (SelectedParty != null && SelectedParty.Id > 0 && SelectedParty.AccountId > 0)
                    {
                        record.Invoice.AccountId = SelectedParty.AccountId;
                    }
                }
                
                // Clear tax cache and recalculate
                ClearTaxCache();
                await CalculateInvoiceTotalsAsync();
                
                // Recalculate retail prices for items in background (non-blocking) when editing
                if (SelectedParty?.Id > 0 && !string.Equals(InvoiceType, "purchase", StringComparison.OrdinalIgnoreCase))
                {
                    // Fire and forget - don't block the UI
                    _ = Task.Run(async () =>
                    {
                        try
                        {
                            await RecalculateAllItemPricesForParty(SelectedParty.Id);
                        }
                        catch { /* ignore errors in background */ }
                    });
                }
                
                // Check if invoice can be edited based on date
                CheckEditPermissions();
                
                // Validate period for the transaction date
                await ValidatePeriodAsync();
                
                // Mark as saved if invoice exists
                if (record.Invoice.Id > 0)
                {
                    _isInvoiceSaved = true;
                    CurrentRecord = record.Invoice.Id; // Ensure CurrentRecord is set
                    await SaveOriginalRecord();
                    
                    // Disable if posted to GL
                    if (record.Invoice.IsPostedToGL == 1)
                    {
                        Disabled = true;
                    }
                    
                    // Track original item IDs to identify new items in updates
                    _originalItemIds = new HashSet<int>(
                        record.InvoiceDetails.Select(d => d.ItemId).Where(id => id > 0)
                    );
                }
                else
                {
                    _isInvoiceSaved = false;
                    CurrentRecord = 0;
                    _originalItemIds.Clear();
                }
            }
            catch (Exception ex)
            {
                ShowError($"Error loading invoice: {ex.Message}");
            }
            finally
            {
                LoadingPanel = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }
    
    private void CheckEditPermissions()
    {
        if (record?.Invoice?.TranDate == null) return;
        
        var invoiceDate = record.Invoice.TranDate.Value.Date;
        var today = DateTime.Now.Date;
        var yesterday = today.AddDays(-1);
        
        // Today's invoices can be edited, yesterday's and older are view-only
        if (invoiceDate < yesterday)
        {
            Disabled = true;
            Action = "VIEW";
        }
        else if (invoiceDate == yesterday)
        {
            Disabled = true;
            Action = "VIEW";
        }
        else
        {
            // Today's invoice - allow editing if not explicitly set to VIEW
            if (!string.Equals(Action, "VIEW", StringComparison.OrdinalIgnoreCase))
            {
                Disabled = false;
            }
        }
    }

    private async Task LoadCategories()
    {
        try
        {
            _categories = await Functions.GetAsync<List<CategoriesModel>>("Categories/SearchCategoriesHavingSomeItems", true) ?? new();
        }
        catch (Exception ex)
        {
            ShowError($"Error loading categories: {ex.Message}");
        }
    }

    private async Task LoadItemsByCategory(CategoriesModel category)
    {
        try
        {
            _activeCategory = category;

            if (category.Id == 0)
            {
                SelectedItems = await Functions.GetAsync<List<ItemsModel>>("Items/Search", true) ?? new();
            }
            else
            {
                SelectedItems = await Functions.GetAsync<List<ItemsModel>>($"Items/Search/Items.CategoryId={category.Id}", true) ?? new();
            }
            
            // Initialize retail prices
            InitializeItemRetailPrices(SelectedItems);
            
            // Recalculate with tax if party is selected
            int partyId = SelectedParty?.Id ?? record?.Invoice?.PartyId ?? 0;
            if (partyId > 0 && !string.Equals(InvoiceType, "purchase", StringComparison.OrdinalIgnoreCase))
            {
                _ = RecalculateRetailPricesForSelectedItemsAsync(partyId);
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            ShowError($"Error loading items: {ex.Message}");
        }
    }
    
    private async Task RecalculateRetailPricesForSelectedItemsAsync(int partyId)
    {
        try
        {
            if (SelectedItems == null || !SelectedItems.Any()) return;
            await RecalculateItemPricesInList(SelectedItems, partyId);
            await InvokeAsync(StateHasChanged);
        }
        catch { /* ignore errors */ }
    }

    // ========== Item Management Methods ==========
    private async Task AddItemDialogShowWithType(string input, string dataType = "i")
    {
        try
        {
            if (string.IsNullOrWhiteSpace(input))
            {
                SelectedItem = null!;
                return;
            }

            var item = await SearchItem(input, dataType);
            if (item == null)
            {
                SelectedItem = null!;
                Snackbar.Add("Item not found", Severity.Warning);
                return;
            }

            SelectedItem = item;
            SelectedItem.Qty = 1;
            InitializeServingSizes(SelectedItem);
            SelectedItem.BasePrice = GetDisplayPrice(SelectedItem);
            await _itemDetailsDialog.Open();
        }
        catch (Exception ex)
        {
            ShowError($"Error loading item: {ex.Message}");
        }
    }

    private async Task<ItemsModel> SearchItem(string input, string dataType)
    {
        string routeSuffix;
        dataType = dataType.Trim().ToLower();

        if (dataType == "i" && int.TryParse(input, out int id))
        {
            routeSuffix = $"/Items.Id={id}";
        }
        else if (dataType == "s")
        {
            string safeInput = input.Replace("'", "''");
            routeSuffix = $"/Items.Code='{safeInput}'";
        }
        else
        {
            return null!;
        }

        var items = await Functions.GetAsync<List<ItemsModel>>($"Items/Search{routeSuffix}", true) ?? new List<ItemsModel>();
        return items.FirstOrDefault()!;
    }

    private void InitializeServingSizes(ItemsModel item)
    {
        item.ServingSizes = new List<ServingSizeModel>();
        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };

        if (!string.IsNullOrWhiteSpace(item.ServingSize))
        {
            try
            {
                var sizes = JsonSerializer.Deserialize<List<ServingSizeModel>>(item.ServingSize, options);
                if (sizes != null && sizes.Any())
                {
                    item.ServingSizes = sizes;
                    item.ServingSize = sizes.FirstOrDefault()?.Size ?? "Medium";
                }
                else
                {
                    item.ServingSizes = new List<ServingSizeModel>();
                    item.ServingSize = "Medium";
                }
            }
            catch
            {
                item.ServingSizes = new List<ServingSizeModel>();
                item.ServingSize = "Medium";
            }
        }
        else
        {
            item.ServingSizes = new List<ServingSizeModel>();
            item.ServingSize = "Medium";
        }
    }

    private async Task AddItemDialogShow(string itemId) => await AddItemDialogShowWithType(itemId, "i");

    private async Task<List<ItemPartyTaxCalculationModel>> GetItemTaxes(int itemId, int partyId)
    {

        var key = (itemId, partyId);
        if (!_taxCache.ContainsKey(key))
        {
            var taxes = await Functions.GetAsync<List<ItemPartyTaxCalculationModel>>($"TaxCalculation/Search/ItemId={itemId} and PartyId={partyId}",true) ?? new List<ItemPartyTaxCalculationModel>();

            _taxCache[key] = taxes;
        }
        return _taxCache[key];
    }

    private void ClearTaxCache()
    {
        _taxCache.Clear();
        _itemsWithTaxRules.Clear();
    }

    private async Task<double> CalculateItemTax(ItemsModel item, double quantity)
    {
        var itemTaxes = await GetItemTaxes(item.Id, record.Invoice.PartyId);
        double taxAmount = 0;

        foreach (var tax in itemTaxes)
        {
            double lineTax = tax.TaxAmount * quantity;
            if (!string.IsNullOrEmpty(InvoiceType) && InvoiceType.ToUpper().Contains("RETURN"))
            {
                lineTax = -lineTax;
            }
            taxAmount += lineTax;
        }

        return taxAmount;
    }

    private double CalculateItemTotal(ItemsModel item, double quantity, double discountAmount, double taxAmount)
    {
        return (item.BasePrice * quantity) - discountAmount + taxAmount;
    }

    // ========== Cart Operations ==========
    private readonly object _invoiceDetailsLock = new object();
    private bool _isAddingToCart = false;
    
    private async Task AddToCart(ItemsModel selectedItem)
    {
        EnsureInvoiceInitialized();
        if (selectedItem == null || selectedItem.BasePrice == 0) return;
        
        // Prevent concurrent additions
        if (_isAddingToCart)
        {
            return;
        }
        
        // Prevent adding items when no party is selected
        if (SelectedParty == null || SelectedParty.Id == 0)
        {
            Snackbar.Add("Please select a party before adding items", Severity.Warning);
            return;
        }

        try
        {
            _isAddingToCart = true;
            
            double taxAmount = await CalculateItemTax(selectedItem, selectedItem.Qty);
            double discountAmount = CalculateItemDiscount(selectedItem);
            double itemTotalAmount = CalculateItemTotal(selectedItem, selectedItem.Qty, discountAmount, taxAmount);

            var row = CreateInvoiceItem(selectedItem, taxAmount, discountAmount, itemTotalAmount);
            
            // Ensure collection modification is thread-safe
            lock (_invoiceDetailsLock)
            {
                if (record.InvoiceDetails == null)
                {
                    record.InvoiceDetails = new ObservableCollection<InvoiceItemReportModel>();
                }
                record.InvoiceDetails.Add(row);
            }

            await _itemDetailsDialog.Close();
            await CalculateInvoiceTotalsAsync();
            CheckForChanges();
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            ShowError($"Error adding item to cart: {ex.Message}");
        }
        finally
        {
            _isAddingToCart = false;
        }
    }

    private double CalculateItemDiscount(ItemsModel item)
    {
        return string.Equals(InvoiceType, "purchase", StringComparison.OrdinalIgnoreCase)
            ? 0
            : item.DefaultDiscount * item.Qty;
    }

    private InvoiceItemReportModel CreateInvoiceItem(ItemsModel item, double taxAmount, double discountAmount, double itemTotalAmount)
    {
        return new InvoiceItemReportModel
        {
            ItemId = item.Id,
            ItemName = item.Name!,
            UnitPrice = item.BasePrice,
            ServingSize = item.ServingSize,
            Qty = item.Qty,
            DiscountAmount = discountAmount,
            TaxAmount = taxAmount,
            ItemTotalAmount = itemTotalAmount
        };
    }

    private InvoiceItemReportModel CreateManualInvoiceItem(string itemName, double qty, double unitPrice, double discountAmount = 0, double taxAmount = 0)
    {
        double itemTotalAmount = (qty * unitPrice) - discountAmount + taxAmount;
        return new InvoiceItemReportModel
        {
            ItemId = 0, // Manual entry has no item ID
            ItemName = itemName,
            ManualItem = itemName, // Save ItemName to ManualItem for manual items
            UnitPrice = unitPrice,
            ServingSize = "",
            Qty = qty,
            DiscountAmount = discountAmount,
            TaxAmount = taxAmount,
            ItemTotalAmount = itemTotalAmount
        };
    }

    private async Task AddManualLine()
    {
        EnsureInvoiceInitialized();
        
        // Prevent adding manual lines when no party is selected
        if (SelectedParty == null || SelectedParty.Id == 0)
        {
            Snackbar.Add("Please select a party before adding items", Severity.Warning);
            return;
        }

        // Show dialog for manual entry
        var parameters = new DialogParameters<ManualLineDialog>
        {
            { x => x.InvoiceType, InvoiceType }
        };

        var options = new DialogOptions
        {
            CloseButton = true,
            MaxWidth = MaxWidth.Medium,
            FullWidth = true
        };

        var dialog = await dialogService.ShowAsync<ManualLineDialog>("Add Manual Line Item", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is ManualLineData manualData)
        {
            try
            {
                // Ask user if they want to add this item to the catalog
                var confirmParameters = new DialogParameters<ConfirmAddToCatalogDialog>
                {
                    { x => x.ItemName, manualData.ItemName }
                };

                var confirmOptions = new DialogOptions
                {
                    CloseButton = true,
                    MaxWidth = MaxWidth.Small,
                    FullWidth = true
                };

                var confirmDialog = await dialogService.ShowAsync<ConfirmAddToCatalogDialog>("Add to Catalog?", confirmParameters, confirmOptions);
                var confirmResult = await confirmDialog.Result;

                if (!confirmResult.Canceled && confirmResult.Data is bool addToCatalog && addToCatalog)
                {
                    // Show dialog to add item to catalog
                    var addItemParameters = new DialogParameters<AddItemToCatalogDialog>
                    {
                        { x => x.ItemName, manualData.ItemName },
                        { x => x.UnitPrice, manualData.UnitPrice },
                        { x => x.Categories, _categories },
                        { x => x.OrganizationId, Globals.User.OrganizationId },
                        { x => x.CreatedBy, Globals.User.Id },
                        { x => x.CreatedFrom, Functions.GetComputerDetails() }
                    };

                    var addItemOptions = new DialogOptions
                    {
                        CloseButton = true,
                        MaxWidth = MaxWidth.Medium,
                        FullWidth = true
                    };

                    var addItemDialog = await dialogService.ShowAsync<AddItemToCatalogDialog>("Add Item to Catalog", addItemParameters, addItemOptions);
                    var addItemResult = await addItemDialog.Result;

                    if (!addItemResult.Canceled && addItemResult.Data is ItemsModel newItem)
                    {
                        LoadingPanel = true;
                        try
                        {
                            // Save the new item
                            var saveResult = await Functions.PostAsync<ItemsModel>("Items/Insert", newItem, true);
                            
                            if (saveResult.Success && saveResult.Result != null)
                            {
                                var savedItem = saveResult.Result;
                                
                                // Reload items data to include the new item
                                await LoadAllItemsData();
                                
                                // Reload items by category if category is selected
                                if (_activeCategory != null)
                                {
                                    await LoadItemsByCategory(_activeCategory);
                                }
                                
                                Snackbar.Add("Item added to catalog successfully", Severity.Success);
                            }
                            else
                            {
                                Snackbar.Add($"Failed to add item to catalog: {saveResult.Message ?? "Unknown error"}", Severity.Warning);
                            }
                        }
                        catch (Exception ex)
                        {
                            Snackbar.Add($"Error adding item to catalog: {ex.Message}", Severity.Warning);
                        }
                        finally
                        {
                            LoadingPanel = false;
                        }
                    }
                }

                // Add the manual line item regardless of catalog addition
                var manualItem = CreateManualInvoiceItem(
                    manualData.ItemName,
                    manualData.Qty,
                    manualData.UnitPrice,
                    manualData.DiscountAmount,
                    manualData.TaxAmount
                );
                
                // Ensure collection modification is thread-safe
                lock (_invoiceDetailsLock)
                {
                    if (record.InvoiceDetails == null)
                    {
                        record.InvoiceDetails = new ObservableCollection<InvoiceItemReportModel>();
                    }
                    record.InvoiceDetails.Add(manualItem);
                }
                
                await CalculateInvoiceTotalsAsync();
                CheckForChanges();
                await InvokeAsync(StateHasChanged);
                Snackbar.Add("Manual line item added successfully", Severity.Success);
            }
            catch (Exception ex)
            {
                ShowError($"Error adding manual line: {ex.Message}");
            }
        }
    }

    private async Task OnRowQtyChangedAsync(QtyChangedEventArgs args)
    {
        try
        {
            if (!ValidateQuantity(args.NewQty)) return;

            EnsureInvoiceInitialized();
            args.Item.Qty = args.NewQty;
            await UpdateInvoiceItem(args.Item);
            await CalculateInvoiceTotalsAsync();
            CheckForChanges();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            ShowError($"Error updating quantity: {ex.Message}");
        }
    }

    private bool ValidateQuantity(double quantity)
    {
        if (quantity <= 0)
        {
            Snackbar.Add("Quantity must be greater than 0", Severity.Warning);
            return false;
        }

        return true;
    }

    private async Task UpdateInvoiceItem(InvoiceItemReportModel invoiceItem)
    {
        var item = ItemsData.FirstOrDefault(i => i.Id == invoiceItem.ItemId);
        if (item != null)
        {
            invoiceItem.DiscountAmount = string.Equals(InvoiceType, "PURCHASE", StringComparison.OrdinalIgnoreCase)
                ? 0
                : item.DefaultDiscount * invoiceItem.Qty;

            invoiceItem.TaxAmount = await CalculateItemTax(item, invoiceItem.Qty);
            invoiceItem.ItemTotalAmount = CalculateItemTotal(item, invoiceItem.Qty, invoiceItem.DiscountAmount, invoiceItem.TaxAmount);
            await CalculateInvoiceTotalsAsync();
        }
    }

    // ========== Serving Size Methods ==========
    private async Task OnServingSizeChangedAsync((string Size, ItemsModel Item) args)
    {
        var (selectedSize, item) = args;
        item.ServingSize = selectedSize;
        UpdateItemPrice(item);

        var invoiceItem = record.InvoiceDetails.FirstOrDefault(i => i.ItemId == item.Id);
        if (invoiceItem != null)
        {
            invoiceItem.UnitPrice = item.BasePrice;
            invoiceItem.ServingSize = selectedSize;
            await UpdateInvoiceItem(invoiceItem);
            await CalculateInvoiceTotalsAsync();
        }

        await InvokeAsync(StateHasChanged);
    }

    private void UpdateItemPrice(ItemsModel item)
    {
        var selectedSize = item.ServingSizes?.FirstOrDefault(s => s.Size == item.ServingSize);
        if (selectedSize != null)
        {
            if (double.TryParse(selectedSize.Price.ToString(), out var price))
                item.BasePrice = price;
        }
        _ = CalculateInvoiceTotalsAsync(); // Fire and forget
    }

    private async Task OnQtyChangedAsync(double val)
    {
        if (!ValidateQuantity(val)) return;

        SelectedItem.Qty = val;
        var selectedSize = SelectedItem.ServingSizes?.FirstOrDefault(s => s.Size == SelectedItem.ServingSize);
        if (selectedSize != null)
        {
            SelectedItem.BasePrice = Convert.ToDouble(selectedSize.Price);
        }
        await CalculateInvoiceTotalsAsync();
        await InvokeAsync(StateHasChanged);
    }

    // ========== Item Deletion ==========
    private async Task DeleteItem(InvoiceItemReportModel item)
    {
        var res = await Functions.ShowConfirmation(dialogService, "Do You want to REMOVE Item?");
        if (res == false) return;

        EnsureInvoiceInitialized();
        
        // Ensure collection modification is thread-safe
        lock (_invoiceDetailsLock)
        {
            if (record.InvoiceDetails != null)
            {
                record.InvoiceDetails.Remove(item);
            }
        }
        
        await CalculateInvoiceTotalsAsync();
        CheckForChanges();
    }

    // ========== Discount Methods ==========
    private async Task ResetChargesToAuto()
    {
        _chargesManuallyOverridden = false;
        await CalculateInvoiceTotalsAsync();
        CheckForChanges();
        await InvokeAsync(StateHasChanged);
    }

    private async Task ResetDiscountToAuto()
    {
        _discountManuallyOverridden = false;
        await CalculateInvoiceTotalsAsync();
        CheckForChanges();
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnChargesDiscountChangedAsync(InvoicesModel updatedInvoice)
    {
        // Service charges and discounts are NOT applicable for purchase invoices
        bool isPurchase = InvoiceType.Equals("PURCHASE", StringComparison.OrdinalIgnoreCase);
        if (isPurchase)
        {
            // Reset charges and discounts to 0 for purchase invoices
            record.Invoice.ChargesAmount = 0;
            record.Invoice.DiscountAmount = 0;
            _chargesManuallyOverridden = false;
            _discountManuallyOverridden = false;
        }
        else
        {
            // For sale invoices, allow charges and discounts
            // Mark as manually overridden when user changes them
            _chargesManuallyOverridden = true;
            _discountManuallyOverridden = true;
            
            record.Invoice.ChargesAmount = updatedInvoice.Invoice.ChargesAmount;
            record.Invoice.DiscountAmount = updatedInvoice.Invoice.DiscountAmount;
        }

        foreach (var item in record.InvoiceDetails)
        {
            item.ItemTotalAmount = (item.UnitPrice * item.Qty) - item.DiscountAmount + item.TaxAmount;
        }

        await CalculateInvoiceTotalsAsync(true);
        CheckForChanges();
        await InvokeAsync(StateHasChanged);
    }

    // ========== Party Methods ==========
    private async Task OpenNewPartyDialog()
    {
        try
        {
            var parameters = new DialogParameters<NewPartyDialog>
            {
                { x => x.OrganizationId, Globals.User.OrganizationId },
                { x => x.CreatedBy, Globals.User.Id },
                { x => x.CreatedFrom, Functions.GetComputerDetails() },
                { x => x.InvoiceType, InvoiceType }
            };

            var options = new DialogOptions
            {
                CloseButton = true,
                MaxWidth = MaxWidth.Medium,
                FullWidth = true
            };

            var dialog = await dialogService.ShowAsync<NewPartyDialog>("Add New Party", parameters, options);
            var result = await dialog.Result;

            if (!result.Canceled && result.Data is PartiesModel newParty)
            {
                LoadingPanel = true;
                try
                {
                    // Save the new party
                    var saveResult = await Functions.PostAsync<PartiesModel>("Parties/Insert", newParty, true);
                    
                    if (saveResult.Success && saveResult.Result != null)
                    {
                        var savedParty = saveResult.Result;
                        
                        // Reload parties list to include the new party
                        await LoadParties();
                        
                        // Select the newly created party
                        SelectedParty = Parties.FirstOrDefault(p => p.Id == savedParty.Id) ?? savedParty;
                        await OnPartyChanged(SelectedParty);
                        
                        Snackbar.Add("Party created successfully", Severity.Success);
                    }
                    else
                    {
                        Snackbar.Add($"Failed to create party: {saveResult.Message ?? "Unknown error"}", Severity.Error);
                    }
                }
                catch (Exception ex)
                {
                    ShowError($"Error creating party: {ex.Message}");
                }
                finally
                {
                    LoadingPanel = false;
                }
            }
        }
        catch (Exception ex)
        {
            ShowError($"Error opening party dialog: {ex.Message}");
        }
    }

    private async Task OnPartyChanged(PartiesModel? selectedParty)
    {
        SelectedParty = selectedParty;
        if (SelectedParty == null)
        {
            // If party is cleared, reset prices to base
            await ResetAllItemPricesToBase();
            record.Invoice.PartyId = 0;
            record.Invoice.PartyName = string.Empty;
            record.Invoice.PartyAddress = string.Empty;
            record.Invoice.AccountId = 0; // Clear AccountId when party is cleared
            await InvokeAsync(StateHasChanged);
            return;
        }

        EnsureInvoiceInitialized();
        record.Invoice.PartyId = SelectedParty.Id;
        ClearTaxCache();
        
        // Update party info
        var party = Parties.FirstOrDefault(p => p.Id == SelectedParty.Id);
        if (party != null)
        {
            record.Invoice.PartyName = party.Name;
            record.Invoice.PartyAddress = party.Address;
            record.Invoice.AccountId = party.AccountId; // Set AccountId from party
        }

        // Recalculate retail prices for all items (ItemsData, FavItemsData, RecentItemsData, SelectedItems)
        await RecalculateAllItemPricesForParty(SelectedParty.Id);

        // Recalculate taxes for existing invoice items
        await RecalculateAllItemTaxes();
        
        await InvokeAsync(StateHasChanged);
    }
    
    private async Task RecalculateAllItemPricesForParty(int partyId)
    {
        if (string.Equals(InvoiceType, "purchase", StringComparison.OrdinalIgnoreCase))
        {
            // For purchase, prices don't change with party
            return;
        }
        
        // Recalculate prices for ItemsData (process in background to avoid blocking)
        // Recalculate prices for all item lists (fire and forget for background lists)
        var backgroundLists = new[] { ItemsData, FavItemsData, RecentItemsData };
        foreach (var itemList in backgroundLists)
        {
            if (itemList != null && itemList.Any())
            {
                _ = Task.Run(async () =>
                {
                    try
                    {
                        await RecalculateItemPricesInList(itemList, partyId);
                    }
                    catch { /* ignore errors */ }
                });
            }
        }
        
        // Recalculate prices for SelectedItems (this one we wait for as it's more immediate)
        if (SelectedItems != null && SelectedItems.Any())
        {
            await RecalculateItemPricesInList(SelectedItems, partyId);
        }
    }
    
    private async Task RecalculateItemPricesInList(List<ItemsModel> items, int partyId)
    {
        if (items == null || !items.Any() || partyId == 0) return;
        
        // Process in batches to avoid blocking
        const int batchSize = 20; // Increased batch size for better performance
        bool needsUpdate = false;
        
        for (int i = 0; i < items.Count; i += batchSize)
        {
            var batch = items.Skip(i).Take(batchSize).ToList();
            
            foreach (var item in batch)
            {
                try
                {
                    double basePrice = item.BasePrice;
                    double discountPerUnit = item.DefaultDiscount;
                    double taxPerUnit = 0;
                    
                    // Get taxes for this item and party
                    var itemTaxes = await GetItemTaxes(item.Id, partyId);
                    if (itemTaxes != null && itemTaxes.Any())
                    {
                        taxPerUnit = itemTaxes.Sum(t => t.TaxAmount);
                        // Track items with tax rules
                        _itemsWithTaxRules.Add(item.Id);
                    }
                    else
                    {
                        // Remove from tax rules set if no taxes
                        _itemsWithTaxRules.Remove(item.Id);
                    }
                    
                    // Calculate retail price: base + tax - discount
                    double newRetailPrice = basePrice + taxPerUnit - discountPerUnit;
                    if (Math.Abs(item.RetailPrice - newRetailPrice) > 0.01) // Only update if changed
                    {
                        item.RetailPrice = newRetailPrice;
                        needsUpdate = true;
                    }
                }
                catch
                {
                    // If tax calculation fails, use base price - discount
                    double fallbackPrice = item.BasePrice - item.DefaultDiscount;
                    if (Math.Abs(item.RetailPrice - fallbackPrice) > 0.01)
                    {
                        item.RetailPrice = fallbackPrice;
                        needsUpdate = true;
                    }
                    // Remove from tax rules set on error
                    _itemsWithTaxRules.Remove(item.Id);
                }
            }
            
            // Yield control periodically to prevent blocking
            if (i + batchSize < items.Count)
            {
                await Task.Yield(); // Better than Delay for responsiveness
            }
        }
        
        // Trigger UI update only if prices changed
        if (needsUpdate)
        {
            await InvokeAsync(StateHasChanged);
        }
    }
    
    private async Task ResetAllItemPricesToBase()
    {
        InitializeItemRetailPrices(ItemsData);
        InitializeItemRetailPrices(FavItemsData);
        InitializeItemRetailPrices(RecentItemsData);
        InitializeItemRetailPrices(SelectedItems);
        await InvokeAsync(StateHasChanged);
    }

    private async Task RecalculateAllItemTaxes()
    {
        foreach (var invoiceItem in record.InvoiceDetails)
        {
            await UpdateInvoiceItem(invoiceItem);
        }
        await CalculateInvoiceTotalsAsync();
    }

    // ========== Payment Methods ==========
    private async Task AddPayment()
    {
        EnsureInvoiceInitialized();
        if (InvoicePayments == null || InvoicePayments.Amount <= 0)
        {
            Snackbar.Add("Please enter a valid payment amount", Severity.Warning);
            return;
        }

        // Validate AccountId (Payment Method) is selected
        if (InvoicePayments.AccountId == 0)
        {
            Snackbar.Add("Please select a Payment Method. Payment Method is required.", Severity.Warning);
            return;
        }

        var toAdd = new InvoicePaymentModel
        {
            AccountId = InvoicePayments.AccountId,
            Amount = InvoicePayments.Amount,
            PaymentMethod = InvoicePayments.PaymentMethod,
            PaymentRef = InvoicePayments.PaymentRef,
            Notes = InvoicePayments.Notes,
            PaidOn = InvoicePayments.PaidOn == default ? DateTime.UtcNow : InvoicePayments.PaidOn,
            IsSoftDeleted = InvoicePayments.IsSoftDeleted
        };

        record.InvoicePayments.Add(toAdd);
        InvoicePayments = new InvoicePaymentModel();
        // Payments don't affect charges/discounts, so recalculate from rules (use false)
        await CalculateInvoiceTotalsAsync();
        CheckForChanges();
        await InvokeAsync(StateHasChanged);
    }

    private async Task DeletePayment(InvoicePaymentModel payment)
    {
        var res = await Functions.ShowConfirmation(dialogService, "Do You want to REMOVE Payment?");
        if (res == false) return;

        EnsureInvoiceInitialized();
        record.InvoicePayments.Remove(payment);
        // Payments don't affect charges/discounts, so recalculate from rules (use false)
        await CalculateInvoiceTotalsAsync();
        CheckForChanges();
        await InvokeAsync(StateHasChanged);
    }

    private void OnPaymentMethodChange()
    {
        EnsureInvoiceInitialized();
        InvoicePayments.Amount = record.Invoice.BalanceAmount;
        StateHasChanged();
    }

    // ========== UI Action Methods ==========
    private async Task Clear()
    {
        record = new InvoicesModel();
        EnsureInvoiceInitialized();
        Disabled = false;
        ClearTaxCache();
        _isInvoiceSaved = false;
        _hasChanges = false;
        _originalRecord = new InvoicesModel();
        _originalItemIds.Clear();
        _chargesManuallyOverridden = false;
        _discountManuallyOverridden = false;
        
        // Initialize currency fields
        if (Currencies != null && Currencies.Any())
        {
            var baseCurrency = Currencies.FirstOrDefault(c => c.IsBaseCurrency == 1);
            if (baseCurrency != null)
            {
                record.Invoice.BaseCurrencyId = baseCurrency.Id;
                record.Invoice.EnteredCurrencyId = baseCurrency.Id;
            }
        }
        record.Invoice.ExchangeRate = 1.0;
        
        // Select first party by default and update prices
        if (Parties != null && Parties.Any())
        {
            SelectedParty = Parties.First();
            record.Invoice.PartyId = SelectedParty.Id;
            
            // Update party info
            record.Invoice.PartyName = SelectedParty.Name;
            record.Invoice.PartyAddress = SelectedParty.Address;
            
            // Recalculate retail prices for all items with the selected party
            await RecalculateAllItemPricesForParty(SelectedParty.Id);
        }
        else
        {
            // If no parties, reset prices to base
            await ResetAllItemPricesToBase();
        }
        
        await CalculateInvoiceTotalsAsync();
        await InvokeAsync(StateHasChanged);
        
        var url = $"/InvoicePage/{InvoiceType}/INSERT/0";
        NavManager.NavigateTo(url);
    }

    private async Task Print()
    {
        try
        {
            var invoiceId = CurrentRecord.GetValueOrDefault();
            
            if (invoiceId == 0)
            {
                Snackbar.Add("Please save the invoice before printing", Severity.Warning);
                return;
            }
            
            // Navigate to report in same tab
            var reportUrl = $"/InvoiceReport/{invoiceId}?withTax=false";
            NavManager.NavigateTo(reportUrl);
        }
        catch (Exception ex)
        {
            ShowError($"Error printing invoice: {ex.Message}");
        }
    }

    // ========== GL Preview Method ==========
    private async Task ShowGLPreview()
    {
        try
        {
            EnsureInvoiceInitialized();
            
            if (record?.Invoice?.PartyId == 0)
            {
                SnackbarService.Add("Please select a party first", Severity.Warning);
                return;
            }

            if (record?.InvoiceDetails == null || !record.InvoiceDetails.Any())
            {
                SnackbarService.Add("Please add items to the invoice first", Severity.Warning);
                return;
            }

            // Recalculate totals before preview
            await CalculateInvoiceTotalsAsync();

            // Validate invoice has required data
            if (record.Invoice.OrganizationId == 0)
            {
                SnackbarService.Add("Organization is required", Severity.Warning);
                return;
            }

            LoadingPanel = true;
            try
            {
                var result = await Functions.PostAsync<GeneralLedgerHeaderModel>("GeneralLedger/PreviewGLFromInvoice", record, true);
                LoadingPanel = false;

                if (result.Success && result.Result != null)
                {
                    int recordId = CurrentRecord.HasValue ? CurrentRecord.Value : 0;
                    var parameters = new DialogParameters<InvoiceGLPreviewDialog>
                    {
                        { x => x.PreviewData, result.Result },
                        { x => x.RecordId, recordId },
                        { x => x.IsPostedToGL, record.Invoice.IsPostedToGL == 1 },
                        { x => x.OnPostToGL, EventCallback.Factory.Create(this, async () => 
                        {
                            await PostToGL();
                            // Refresh preview after posting
                            await ShowGLPreview();
                        }) }
                    };

                    var options = new DialogOptions()
                    {
                        MaxWidth = MaxWidth.Large,
                        FullWidth = true,
                        CloseButton = true,
                        CloseOnEscapeKey = true,
                        BackdropClick = false
                    };

                    await dialogService.ShowAsync<InvoiceGLPreviewDialog>("Accounting Entry Preview", parameters, options);
                }
                else
                {
                    // Extract error message - avoid duplication if it already contains "Unable to generate preview"
                    string errorMsg = !string.IsNullOrWhiteSpace(result.Message) 
                        ? result.Message 
                        : "Unable to generate preview. Please ensure all required accounts (AR/AP, Revenue/Expense, Tax, Service Charges, Discount) are configured in Chart of Accounts.";
                    
                    // Remove duplication if message already starts with "Unable to generate preview"
                    if (errorMsg.StartsWith("Unable to generate preview", StringComparison.OrdinalIgnoreCase))
                    {
                        SnackbarService.Add(errorMsg, Severity.Error);
                    }
                    else
                    {
                        SnackbarService.Add($"Unable to generate preview: {errorMsg}", Severity.Error);
                    }
                }
            }
            catch (Exception ex)
            {
                LoadingPanel = false;
                SnackbarService.Add($"Error generating preview: {ex.Message}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            LoadingPanel = false;
            ShowError($"Error generating preview: {ex.Message}");
        }
    }

    private async Task PostToGL()
    {
        try
        {
            var invoiceId = CurrentRecord.GetValueOrDefault();
            
            if (invoiceId == 0)
            {
                Snackbar.Add("Please save the invoice before posting to GL", Severity.Warning);
                return;
            }

            if (record.Invoice.IsPostedToGL == 1)
            {
                Snackbar.Add("This invoice is already posted to General Ledger", Severity.Info);
                return;
            }

            var res = await Functions.ShowConfirmation(dialogService, "Do you want to post this invoice to General Ledger? Once posted, it cannot be edited or deleted.");
            if (res == false)
                return;

            LoadingPanel = true;
            var result = await Functions.PostAsync<GeneralLedgerHeaderModel>(
                $"GeneralLedger/CreateGLFromInvoice/{invoiceId}?userId={Globals.User.Id}&clientInfo={Uri.EscapeDataString(Globals.ClientInfo)}", 
                null, 
                true);
            LoadingPanel = false;

            if (result.Success == false)
            {
                SnackbarService.Add($"ERROR: {result.Message}", Severity.Error);
            }
            else
            {
                SnackbarService.Add("Invoice posted to General Ledger successfully", Severity.Success);
                // Reload invoice to get updated IsPostedToGL status
                await Get(invoiceId);
            }
        }
        catch (Exception ex)
        {
            LoadingPanel = false;
            ShowError($"Error posting to GL: {ex.Message}");
        }
    }

    private async Task OpenOptionsDrawer() => await _optionsDrawer.Open();
    private async Task OpenPaymentDialog() => await _paymentDialog.Open();
    private async Task OpenTaxDialog() => await _tax_dialog.Open();
    private async Task OpenItemsDrawer()
    {
        _itemsDrawerOpen = true;
        await _itemsDrawer.OpenDrawerAsync();
    }

    private async Task HandleItemSelected(string itemId)
    {
        await AddItemDialogShow(itemId);
        // Close drawer after item selection
        _itemsDrawerOpen = false;
        await _itemsDrawer.CloseDrawerAsync();
    }

    // When user clicks "Taxes" in a line, populate selected line tax details and show the dialog.
    private async Task OnItemSelection(InvoiceItemReportModel row)
    {
        try
        {
            // set SelectedItem for the ItemTaxPreview binding
            var item = ItemsData.FirstOrDefault(i => i.Id == row.ItemId);
            if (item == null)
            {
                SelectedItem = new ItemsModel { Id = row.ItemId, Name = row.ItemName, Qty = row.Qty, BasePrice = row.UnitPrice };
            }
            else
            {
                SelectedItem = item;
                SelectedItem.Qty = row.Qty;
                SelectedItem.BasePrice = row.UnitPrice;
            }

            // fetch precalculated tax lines for this item & party
            SelectedItemTaxes = await GetItemTaxes(row.ItemId, record.Invoice.PartyId) ?? new List<ItemPartyTaxCalculationModel>();

            // compute tax total for the quantity on the line (account for RETURN type)
            var computed = SelectedItemTaxes.Sum(t => t.TaxAmount) * row.Qty;
            if (!string.IsNullOrEmpty(InvoiceType) && InvoiceType.ToUpper().Contains("RETURN"))
                computed = -computed;

            SelectedItemTaxTotal = computed;

            // quick reconciliation check (non-blocking)
            var lineTax = row.TaxAmount;
            var diff = Math.Abs(SelectedItemTaxTotal - lineTax);
            if (diff > 0.0001)
            {
                Snackbar.Add($"Tax calculation differs from line total by {diff:N2}. Showing breakdown.", Severity.Warning);
            }

            // Trigger state change to ensure ItemTaxPreview receives updated parameters
            await InvokeAsync(StateHasChanged);
            _myTaxDialog?.Show();
        }
        catch (Exception ex)
        {
            ShowError($"Error showing tax details: {ex.Message}");
        }
    }

    private void ClosePaymentDialog()
    {
        StateHasChanged();
    }

    // ========== Save Method ==========
    private async Task Save()
    {
        try
        {
            EnsureInvoiceInitialized();
            var actionType = CurrentRecord.GetValueOrDefault() != 0 ? "UPDATE" : "INSERT";

            // Recalculate invoice totals (including charges and discounts) before save
            await CalculateInvoiceTotalsAsync();
            
            PrepareInvoiceForSave(actionType);
            await PopulateInvoiceTaxesBeforeSaveAsync();

            LoadingPanel = true;
            var result = await Functions.PostAsync<InvoiceModel>($"Invoice/{actionType}", record, true);
            LoadingPanel = false; // Hide loading panel immediately after API call
            
            if (result.Success == false || result.Result == null)
            {
                // Check if error is related to stock availability for sale invoices
                if (record.Invoice.InvoiceType?.ToUpper() == "SALE" && 
                    record.Invoice.LocationId > 0 && 
                    !record.Invoice.SkipStockValidation &&
                    (result.Message?.Contains("Insufficient stock", StringComparison.OrdinalIgnoreCase) == true ||
                     result.Message?.Contains("stock", StringComparison.OrdinalIgnoreCase) == true))
                {
                    // Ensure loading panel is hidden and UI is updated before showing confirmation
                    LoadingPanel = false;
                    await InvokeAsync(StateHasChanged);
                    // Give UI time to remove loading overlay before showing dialog
                    await Task.Delay(150);
                    
                    // Stock is insufficient, ask for confirmation
                    var confirmed = await Functions.ShowConfirmation(dialogService, 
                        $"Stock Warning:\n\n{result.Message}\n\nDo you want to proceed and save the invoice anyway?");
                    
                    if (confirmed)
                    {
                        // User confirmed, set flag to skip stock validation and retry save
                        record.Invoice.SkipStockValidation = true;
                        
                        // Show loading panel immediately after confirmation
                        LoadingPanel = true;
                        await InvokeAsync(StateHasChanged);
                        await Task.Delay(50); // Small delay to ensure loading panel is visible
                        
                        result = await Functions.PostAsync<InvoiceModel>($"Invoice/{actionType}", record, true);
                        LoadingPanel = false;
                        
                        // Reset the flag after retry
                        record.Invoice.SkipStockValidation = false;
                        
                        if (result.Success == false || result.Result == null)
                        {
                            SnackbarService.Add($"ERROR: {result.Message}", Severity.Error);
                        }
                        else
                        {
                            var res = result.Result;
                            SnackbarService.Add($"Record {actionType} Successfully", Severity.Success);
                            
                            // Mark as saved and reset change tracking
                            _isInvoiceSaved = true;
                            _hasChanges = false;
                            await SaveOriginalRecord();
                            
                            await Get(res.Id);
                            CurrentRecord = res.Id;
                            Action = "UPDATE";
                            
                            // Notify parent component after successful save
                            await OnSaved.InvokeAsync();
                        }
                    }
                    else
                    {
                        // User cancelled, don't save
                        return;
                    }
                }
                else
                {
                    LoadingPanel = false;
                    SnackbarService.Add($"ERROR: {result.Message}", Severity.Error);
                }
            }
            else
            {
                LoadingPanel = false;
                var res = result.Result;
                SnackbarService.Add($"Record {actionType} Successfully", Severity.Success);
                
                // Mark as saved and reset change tracking
                _isInvoiceSaved = true;
                _hasChanges = false;
                await SaveOriginalRecord();
                
                await Get(res.Id);
                CurrentRecord = res.Id;
                Action = "UPDATE";
                
                // Notify parent component after successful save
                await OnSaved.InvokeAsync();
            }
        }
        catch (Exception ex)
        {
            LoadingPanel = false;
            record.Invoice.SkipStockValidation = false; // Reset flag on error
            ShowError($"Error saving Invoice: {ex.Message}");
        }
    }
    
    private async Task SaveOriginalRecord()
    {
        // Deep copy the current record state for change tracking
        _originalRecord = new InvoicesModel
        {
            Invoice = new InvoiceModel
            {
                Id = record.Invoice.Id,
                TotalInvoiceAmount = record.Invoice.TotalInvoiceAmount,
                TotalPayments = record.Invoice.TotalPayments,
                BalanceAmount = record.Invoice.BalanceAmount,
                ChargesAmount = record.Invoice.ChargesAmount,
                DiscountAmount = record.Invoice.DiscountAmount,
                TaxAmount = record.Invoice.TaxAmount,
                InvoiceAmount = record.Invoice.InvoiceAmount
            },
            InvoiceDetails = new ObservableCollection<InvoiceItemReportModel>(
                record.InvoiceDetails.Select(d => new InvoiceItemReportModel
                {
                    ItemId = d.ItemId,
                    Qty = d.Qty,
                    UnitPrice = d.UnitPrice,
                    TaxAmount = d.TaxAmount,
                    DiscountAmount = d.DiscountAmount,
                    ItemTotalAmount = d.ItemTotalAmount
                })
            ),
            InvoicePayments = new ObservableCollection<InvoicePaymentModel>(
                record.InvoicePayments.Select(p => new InvoicePaymentModel
                {
                    Id = p.Id,
                    Amount = p.Amount,
                    PaymentMethod = p.PaymentMethod
                })
            )
        };
    }
    
    private void CheckForChanges()
    {
        if (!_isInvoiceSaved) return;
        
        bool hasChanges = false;
        
        // Check invoice totals
        if (_originalRecord.Invoice != null && record.Invoice != null)
        {
            hasChanges = Math.Abs((decimal)(_originalRecord.Invoice.TotalInvoiceAmount - record.Invoice.TotalInvoiceAmount)) > 0.01m ||
                        Math.Abs((decimal)(_originalRecord.Invoice.TotalPayments - record.Invoice.TotalPayments)) > 0.01m ||
                        _originalRecord.InvoiceDetails.Count != record.InvoiceDetails.Count ||
                        _originalRecord.InvoicePayments.Count != record.InvoicePayments.Count;
        }
        
        // Check details
        if (!hasChanges && _originalRecord.InvoiceDetails != null && record.InvoiceDetails != null)
        {
            if (_originalRecord.InvoiceDetails.Count == record.InvoiceDetails.Count)
            {
                for (int i = 0; i < record.InvoiceDetails.Count; i++)
                {
                    var orig = _originalRecord.InvoiceDetails[i];
                    var curr = record.InvoiceDetails[i];
                    if (orig.ItemId != curr.ItemId ||
                        Math.Abs(orig.Qty - curr.Qty) > 0.01 ||
                        Math.Abs(orig.UnitPrice - curr.UnitPrice) > 0.01 ||
                        Math.Abs(orig.TaxAmount - curr.TaxAmount) > 0.01 ||
                        Math.Abs(orig.DiscountAmount - curr.DiscountAmount) > 0.01)
                    {
                        hasChanges = true;
                        break;
                    }
                }
            }
        }
        
        _hasChanges = hasChanges;
    }

    private void PrepareInvoiceForSave(string actionType)
    {
        if (string.Equals(actionType, "INSERT", StringComparison.OrdinalIgnoreCase))
        {
            record.Invoice.CreatedBy = Globals.User.Id;
            record.Invoice.CreatedOn = DateTime.Now;
            record.Invoice.CreatedFrom = Functions.GetComputerDetails();
        }

        record.Invoice.OrganizationId = Globals.User.OrganizationId;
        record.Invoice.Source = "MANUAL";
        record.Invoice.LocationId = Globals.User.LocationId;
        record.Invoice.UpdatedBy = Globals.User.Id;
        record.Invoice.UpdatedOn = DateTime.Now;
        record.Invoice.UpdatedFrom = Functions.GetComputerDetails();
    }

    private async Task PopulateInvoiceTaxesBeforeSaveAsync()
    {
        EnsureInvoiceInitialized();

        // prepare global invoice taxes collection
        record.InvoiceTaxes = new ObservableCollection<InvoiceDetailTaxesModel>();

        // Assign temporary ids to details if needed (keeps existing behavior)
        foreach (var detail in record.InvoiceDetails)
        {
            try
            {
                var idProp = detail.GetType().GetProperty("Id");
                if (idProp != null)
                {
                    var current = idProp.GetValue(detail);
                    if (current is int existingId && existingId != 0)
                    {
                        // keep existing
                    }
                    else
                    {
                        idProp.SetValue(detail, _tempDetailIdCounter--);
                    }
                }
            }
            catch { /* ignore */ }
        }

        // For each invoice detail, fetch the calculated taxes and add entries to InvoiceTaxes.
        foreach (var detail in record.InvoiceDetails)
        {
            try
            {
                var item = ItemsData.FirstOrDefault(i => i.Id == detail.ItemId);
                if (item == null) continue;

                var taxes = await GetItemTaxes(item.Id, record.Invoice.PartyId);
                if (taxes == null || !taxes.Any()) continue;

                // compute taxable base for the line (unit price * qty - discount)
                var taxableBase = (detail.UnitPrice * detail.Qty) - detail.DiscountAmount;
                foreach (var t in taxes)
                {
                    // taxAmount per unit in ItemPartyTaxCalculationModel * qty
                    var taxAmountForLine = t.TaxAmount * detail.Qty;
                    if (!string.IsNullOrEmpty(InvoiceType) && InvoiceType.ToUpper().Contains("RETURN"))
                        taxAmountForLine = -taxAmountForLine;

                    var taxEntry = new InvoiceDetailTaxesModel
                    {
                        Id = 0,
                        InvoiceDetailId = detail.ItemId, 
                        TaxId = t.TaxName ?? string.Empty,
                        TaxRate = t.Percentage,
                        TaxableAmount = (decimal)taxableBase,
                        TaxAmount = (decimal)taxAmountForLine
                    };

                    record.InvoiceTaxes.Add(taxEntry);

                    // also add into detail's AppliedTaxes where available
                    try
                    {
                        var applied = detail.GetType().GetProperty("AppliedTaxes");
                        if (applied != null)
                        {
                            var list = applied.GetValue(detail) as IList<InvoiceDetailTaxesModel>;
                            if (list != null)
                                list.Add(new InvoiceDetailTaxesModel
                                {
                                    Id = 0,
                                    InvoiceDetailId = detail.ItemId,
                                    TaxId = t.TaxName ?? string.Empty,
                                    TaxRate = t.Percentage,
                                    TaxableAmount = (decimal)taxableBase,
                                    TaxAmount = (decimal)taxAmountForLine
                                });
                        }
                    }
                    catch { /* ignore */ }
                }
            }
            catch { /* ignore per-line errors */ }
        }
    }

    // ========== Helper Methods ==========
    private void EnsureInvoiceInitialized()
    {
        if (record == null) record = new InvoicesModel();
        if (record.Invoice == null) record.Invoice = new InvoiceModel();
        if (record.InvoiceDetails == null) record.InvoiceDetails = new ObservableCollection<InvoiceItemReportModel>();
        if (record.InvoicePayments == null) record.InvoicePayments = new ObservableCollection<InvoicePaymentModel>();
        
        // Initialize currency fields if not set
        if (Currencies != null && Currencies.Any())
        {
            var baseCurrency = Currencies.FirstOrDefault(c => c.IsBaseCurrency == 1);
            if (baseCurrency != null)
            {
                if (record.Invoice.BaseCurrencyId == 0)
                    record.Invoice.BaseCurrencyId = baseCurrency.Id;
                if (record.Invoice.EnteredCurrencyId == 0)
                    record.Invoice.EnteredCurrencyId = baseCurrency.Id;
            }
        }
        if (record.Invoice.ExchangeRate == 0)
            record.Invoice.ExchangeRate = 1.0;
        if (record.InvoiceCharges == null) record.InvoiceCharges = new ObservableCollection<InvoiceChargesModel>();
    }

    private double GetDisplayPrice(ItemsModel item)
    {
        if (item == null) return 0;
        // Return RetailPrice if set, otherwise fallback to base/cost price
        return item.RetailPrice != 0 
            ? item.RetailPrice 
            : (string.Equals(InvoiceType, "purchase", StringComparison.OrdinalIgnoreCase) ? item.CostPrice : item.BasePrice);
    }
    
    private bool HasTaxRule(ItemsModel item)
    {
        if (item == null) return false;
        
        // Purchase invoices don't have tax rules
        if (string.Equals(InvoiceType, "purchase", StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }
        
        // Check if item has tax rules by checking the tracked set
        return _itemsWithTaxRules.Contains(item.Id);
    }

    private Task<IEnumerable<PartiesModel>> SearchParties(string searchText, CancellationToken cancellationToken)
    {
        return Task.FromResult(
            string.IsNullOrWhiteSpace(searchText)
                ? Parties
                : Parties.Where(p =>
                    p.DisplayName.Contains(searchText, StringComparison.OrdinalIgnoreCase)
                )
        );
    }

    private void ShowError(string message)
    {
        SnackbarService.Add(message, Severity.Error);
    }

    private async Task OnTranDateChanged()
    {
        await ValidatePeriodAsync();
    }

    private async Task ValidatePeriodAsync()
    {
        PeriodValidationChecked = false;
        PeriodValidationMessage = string.Empty;
        
        if (record?.Invoice?.TranDate == null || record.Invoice.OrganizationId == 0)
        {
            PeriodValidationMessage = string.Empty;
            await InvokeAsync(StateHasChanged);
            return;
        }

        try
        {
            // Use SALE or PURCHASE module type based on invoice type
            // Handle: "PURCHASE", "PURCHASE RETURN"  "PURCHASE"
            // Handle: "SALE", "SALE RETURN", or anything else  "SALE"
            string invoiceTypeUpper = record.Invoice.InvoiceType?.ToUpper().Trim() ?? "";
            string moduleType = invoiceTypeUpper.Contains("PURCHASE") ? "PURCHASE" : "SALE";
            string dateStr = record.Invoice.TranDate.Value.ToString("yyyy-MM-dd");
            
            // Build the API URL - date is already in safe yyyy-MM-dd format, no need to escape
            // ModuleType is also safe (SALE/PURCHASE/ALL), but we'll escape it to be safe
            string apiUrl = $"PeriodClose/GetOpenPeriod/{record.Invoice.OrganizationId}/{dateStr}/{moduleType}";
            
            // Log the API call for debugging
            Console.WriteLine($"InvoicePage ValidatePeriod: Calling API: {apiUrl}");
            Console.WriteLine($"InvoicePage ValidatePeriod: OrganizationId={record.Invoice.OrganizationId}, Date={dateStr}, ModuleType={moduleType}, InvoiceType={record.Invoice.InvoiceType}");
            
            // Use GetAsync and check if we got a valid result
            var result = await Functions.GetAsync<PeriodCloseModel>(apiUrl, true);
            
            Console.WriteLine($"InvoicePage ValidatePeriod: API Response - Result is null: {result == null}, Id: {result?.Id ?? 0}, Status: {result?.Status ?? "null"}, ModuleType: {result?.ModuleType ?? "null"}");

            PeriodValidationChecked = true;

            // Period is OPEN if we get a valid result with Id > 0 and Status is OPEN or OPEN_PENDING
            // Period is CLOSED if result is null, Id is 0, or Status is CLOSE
            if (result != null && result.Id > 0)
            {
                string statusUpper = result.Status?.ToUpper().Trim() ?? "";
                if (statusUpper == "OPEN" || statusUpper == "OPEN_PENDING")
                {
                    // Period is open - clear message (don't show any message when open)
                    PeriodValidationMessage = string.Empty;
                    PeriodValidationChecked = true;
                }
                else
                {
                    // Period exists but is closed
                    PeriodValidationMessage = $" Period is CLOSED for {moduleType} module on {dateStr}. The period '{result.PeriodName}' exists but has status '{result.Status}'. Please open the period before saving transactions.";
                    PeriodValidationChecked = true;
                }
            }
            else
            {
                // No period found or period is closed - show warning
                // But first check if there's a debugging issue - log the API response
                PeriodValidationMessage = $" Period is CLOSED for {moduleType} module on {dateStr}. No open period found for this date. Please ensure the period is open before saving transactions.";
                PeriodValidationChecked = true;
            }
        }
        catch (Exception ex)
        {
            PeriodValidationChecked = true;
            PeriodValidationMessage = $"Error checking period status: {ex.Message}";
            SnackbarService.Add(PeriodValidationMessage, Severity.Error);
        }
        
        await InvokeAsync(StateHasChanged);
    }


    private async Task<(List<InvoiceChargesModel> charges, decimal service, decimal discount)> CalculateCharges(decimal baseAmount)
    {
        try
        {
            var checkDate = record.Invoice.TranDate?.ToString("yyyy-MM-dd") ?? string.Empty;

            var criteria =
                $"a.IsActive = 1 AND ('{checkDate}' BETWEEN EffectiveFrom AND EffectiveTo " +
                $"OR ('{checkDate}' >= EffectiveFrom AND EffectiveTo IS NULL))";

            var encodedCriteria = Uri.EscapeDataString(criteria);

            var rules = await Functions.GetAsync<List<InvoiceChargesRulesModel>>(
                $"InvoiceChargesRules/Search/{encodedCriteria}", true)
                ?? new List<InvoiceChargesRulesModel>();

            decimal service = CalculateChargeAmount(rules, "SERVICE", baseAmount);
            decimal discount = CalculateChargeAmount(rules, "DISCOUNT", baseAmount);

            var charges = rules.Select(rule =>
            {
                decimal appliedAmount;
                if (rule.AmountType == "PERCENTAGE")
                {
                    // Percentage charges: always calculate based on base amount
                    appliedAmount = baseAmount * (decimal)rule.Amount / 100m;
                }
                else // FLAT
                {
                    // Flat charges: only apply if invoice amount is greater than or equal to the flat amount
                    decimal flatAmount = (decimal)rule.Amount;
                    appliedAmount = baseAmount >= flatAmount ? flatAmount : 0m;
                }

                return new InvoiceChargesModel
                {
                    RulesId = rule.Id,
                    AccountId = rule.AccountId,
                    ChargeCategory = rule.ChargeCategory,
                    AmountType = rule.AmountType,
                    Amount = rule.Amount,
                    AppliedAmount = (double) appliedAmount,   
                    IsSoftDeleted = 0
                };
            }).Where(c => c.AppliedAmount > 0).ToList(); // Only include charges that are actually applied

            return (charges, service, discount);
        }
        catch (Exception ex)
        {
            ShowError($"Error calculating charges: {ex.Message}");
            return (new List<InvoiceChargesModel>(), 0, 0);
        }
    }

    private async Task CalculateInvoiceTotalsAsync(bool isManuallyChanged = false)
    {
        try
        {
            EnsureInvoiceInitialized();

            // -------- Item-level calculations --------
            foreach (var item in record.InvoiceDetails)
            {
                var product = ItemsData.FirstOrDefault(i => i.Id == item.ItemId);
                if (product == null) continue;

                // Only apply default discount if not purchase
                item.DiscountAmount = InvoiceType.Equals("PURCHASE", StringComparison.OrdinalIgnoreCase)
                    ? 0
                    : product.DefaultDiscount * item.Qty;

                item.TaxAmount = await CalculateItemTax(product, item.Qty);

                item.ItemTotalAmount = (item.Qty * item.UnitPrice) + item.TaxAmount - item.DiscountAmount;
            }

            // -------- Base Invoice --------
            record.Invoice.TotalQty = (decimal)record.InvoiceDetails.Sum(i => i.Qty);
            record.Invoice.TaxAmount = (decimal)record.InvoiceDetails.Sum(i => i.TaxAmount);
            record.Invoice.InvoiceAmount = (decimal)record.InvoiceDetails.Sum(i => i.ItemTotalAmount);

            // -------- Charges & Discounts --------
            // Service charges and discounts are NOT applicable for purchase invoices
            bool isPurchase = InvoiceType.Equals("PURCHASE", StringComparison.OrdinalIgnoreCase);
            
            if (isPurchase)
            {
                // For purchase invoices: no charges or discounts
                record.Invoice.ChargesAmount = 0;
                record.Invoice.DiscountAmount = 0;
                record.InvoiceCharges = new ObservableCollection<InvoiceChargesModel>();
            }
            else
            {
                // For sale invoices: calculate charges and discounts
                // Check if charges/discounts were manually overridden
                bool shouldRecalculateCharges = !isManuallyChanged && !_chargesManuallyOverridden;
                bool shouldRecalculateDiscount = !isManuallyChanged && !_discountManuallyOverridden;
                
                if (shouldRecalculateCharges && shouldRecalculateDiscount)
                {
                    // Both are auto-calculated: calculate from rules table and update both amounts and charges collection
                    (List<InvoiceChargesModel> chargesList, decimal serviceAmount, decimal discountAmount) = await CalculateCharges(record.Invoice.InvoiceAmount);

                    record.Invoice.ChargesAmount = serviceAmount;
                    record.Invoice.DiscountAmount = discountAmount;
                    record.InvoiceCharges = new ObservableCollection<InvoiceChargesModel>(chargesList);
                    
                    // Reset manual override flags since we're auto-calculating
                    _chargesManuallyOverridden = false;
                    _discountManuallyOverridden = false;
                }
                else
                {
                    // At least one is manually overridden: preserve manual values
                    // If InvoiceCharges is null or empty, we need to calculate from rules to get the structure
                    // but we'll adjust the AppliedAmount to match the manual amounts
                    if (record.InvoiceCharges == null || record.InvoiceCharges.Count == 0)
                    {
                        // No existing charges structure, calculate from rules to get the structure
                        (List<InvoiceChargesModel> chargesList, decimal calculatedService, decimal calculatedDiscount) = await CalculateCharges(record.Invoice.InvoiceAmount);
                        
                        // Adjust AppliedAmount in each charge to proportionally match manual amounts
                        if (chargesList.Any())
                        {
                            foreach (var charge in chargesList)
                            {
                                if (charge.ChargeCategory?.ToUpper() == "SERVICE" && calculatedService > 0 && _chargesManuallyOverridden)
                                {
                                    // Proportionally adjust service charge to match manual amount
                                    charge.AppliedAmount = (double)((decimal)charge.AppliedAmount * record.Invoice.ChargesAmount / calculatedService);
                                }
                                else if (charge.ChargeCategory?.ToUpper() == "DISCOUNT" && calculatedDiscount > 0 && _discountManuallyOverridden)
                                {
                                    // Proportionally adjust discount to match manual amount
                                    charge.AppliedAmount = (double)((decimal)charge.AppliedAmount * record.Invoice.DiscountAmount / calculatedDiscount);
                                }
                            }
                        }
                        
                        record.InvoiceCharges = new ObservableCollection<InvoiceChargesModel>(chargesList);
                    }
                    // else: keep existing InvoiceCharges collection (user manually changed amounts, preserve charge structure)
                }
            }

            // Total invoice amount = item totals + tax + charges - discount
            record.Invoice.TotalInvoiceAmount = record.Invoice.InvoiceAmount
                                               + record.Invoice.TaxAmount
                                               + record.Invoice.ChargesAmount
                                               - record.Invoice.DiscountAmount;

            // -------- Payments & Balance --------
            record.Invoice.TotalPayments = record.InvoicePayments?.Sum(x => x.Amount) ?? 0;
            record.Invoice.BalanceAmount = record.Invoice.TotalInvoiceAmount - record.Invoice.TotalPayments;
        }
        catch (Exception ex)
        {
            ShowError($"Error calculating invoice totals: {ex.Message}");
        }
    }


    private decimal CalculateChargeAmount(List<InvoiceChargesRulesModel> rules, string category, decimal baseAmount)
    {
        return rules
            .Where(r => r.ChargeCategory == category)
            .Sum(r => 
            {
                if (r.AmountType == "PERCENTAGE")
                {
                    // Percentage charges: always calculate based on base amount
                    return baseAmount * (decimal)r.Amount / 100m;
                }
                else // FLAT
                {
                    // Flat charges: only apply if invoice amount is greater than or equal to the flat amount
                    decimal flatAmount = (decimal)r.Amount;
                    return baseAmount >= flatAmount ? flatAmount : 0m;
                }
            });
    }


}

<style>
    .invoice-header-gradient {
        padding: 12px 16px;
        background: linear-gradient(135deg, var(--mud-palette-primary-lighten) 0%, var(--mud-palette-primary) 100%);
        border-radius: 12px;
        color: white;
        margin-bottom: 16px;
    }

    .invoice-header-gradient .mud-typography {
        color: white !important;
    }

    .invoice-header-btn {
        background: rgba(255, 255, 255, 0.2) !important;
        border: 1px solid rgba(255, 255, 255, 0.3) !important;
        color: white !important;
        white-space: nowrap;
        min-width: auto;
        padding: 6px 12px !important;
    }

    .invoice-header-btn:hover {
        background: rgba(255, 255, 255, 0.3) !important;
    }

    .invoice-header-btn:disabled {
        background: rgba(255, 255, 255, 0.1) !important;
        opacity: 0.5;
    }

    /* Dark mode adjustments */
    .mud-theme-dark .invoice-header-gradient {
        background: linear-gradient(135deg, var(--mud-palette-primary-darken) 0%, var(--mud-palette-primary) 100%);
    }

    .mud-theme-dark .invoice-header-btn {
        background: rgba(0, 0, 0, 0.2) !important;
        border: 1px solid rgba(0, 0, 0, 0.3) !important;
        color: white !important;
    }

    /* Invoice Details Row - Equal width flexbox layout */
    .invoice-details-row {
        display: flex;
        gap: 12px;
        align-items: flex-start;
        flex-wrap: nowrap;
        width: 100%;
    }

    .invoice-field {
        flex: 1 1 0;
        min-width: 0;
        display: flex;
        flex-direction: column;
    }

    .invoice-field-equal {
        flex: 1 1 0;
        min-width: 140px;
        max-width: 100%;
    }

    .invoice-field-label {
        font-size: 0.75rem;
        color: var(--mud-palette-text-primary);
        margin-bottom: 4px;
        display: block;
    }

    .invoice-currency-display {
        min-height: 40px;
        padding: 8px 12px;
        background: rgba(63, 81, 181, 0.08);
        border-radius: 4px;
        border: 1px solid rgba(63, 81, 181, 0.2);
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s ease;
    }

    .invoice-currency-display:hover {
        background: rgba(63, 81, 181, 0.12) !important;
        border-color: rgba(63, 81, 181, 0.3);
    }

    .invoice-currency-text {
        color: var(--mud-palette-primary);
        font-size: 0.875rem;
        flex: 1;
    }

    .invoice-currency-edit-btn {
        min-width: 24px;
        width: 24px;
        height: 24px;
        padding: 2px;
    }

    .invoice-field-input {
        width: 100%;
    }

    /* Responsive: stack on medium screens */
    @@media (max-width: 1200px) {
        .invoice-details-row {
            flex-wrap: wrap;
            gap: 8px;
        }

        .invoice-field-equal {
            flex: 1 1 calc(50% - 4px);
            min-width: 150px;
        }
    }

    @@media (max-width: 768px) {
        .invoice-field-equal {
            flex: 1 1 100%;
            min-width: 100%;
        }
    }

    /* Ensure grid items don't overflow */
    .mud-grid-item {
        max-width: 100%;
        overflow: hidden;
    }

    /* Prevent horizontal scrolling */
    .mud-main-content {
        overflow-x: hidden !important;
    }

    /* Invoice main content height management */
    .invoice-main-content {
        max-height: calc(100vh - 280px);
        overflow-y: auto;
        overflow-x: hidden;
    }

    /* Ensure MudGrid doesn't overflow */
    .invoice-main-content .mud-grid {
        margin: 0;
    }

    /* Ensure MudGrid items fit properly */
    .invoice-main-content .mud-grid-item {
        max-width: 100%;
    }

</style>